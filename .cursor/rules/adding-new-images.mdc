---
alwaysApply: true
---
# Adding New Docker Images

## Workflow

1. **Create Dockerfile** - Write and refine the Dockerfile
2. **Build Locally** - Build and test the image thoroughly
3. **Create Workflow** - Add GitHub Actions workflow for CI/CD
4. **Generate Documentation** - Only after successful build, create README

## Directory Structure

Create new directory: `images/<image-name>/` containing:
- `Dockerfile` - Image definition
- `README.md` - Comprehensive documentation
- Supporting files as needed

## Dockerfile Requirements

- Base image with version
- Build arguments for version pinning
- Environment variables for tool paths
- Working directory `/workspace`
- Verification step
- Layer optimization (combine RUN commands, cleanup)

## README Requirements

Image README must include:
- Overview and description
- What's Inside (specific versions)
- Quick Start (pull, build, run)
- Usage Examples
- CI/CD Integration examples
- Environment Variables
- Building the Image

- Version Information table

## Update Root README

Add new image to the table in root README. Keep it minimal - just image name, brief description, and link.

## Registry Naming

Images published as: `ghcr.io/jethome-iot/jethome-dev-<image-name>`

## GitHub Actions Workflow

Create `.github/workflows/<image-name>.yml`:
- Use reusable workflow: `.github/workflows/docker-build.yml`
- Set triggers for image directory and workflow file changes
- Define default version in `env` section
- Add `prepare` job to resolve versions
- Pass `image_name`, `context_path`, and `version_tag` parameters
- Pass version to Dockerfile via `build_args`
- Include manual trigger with required version input
- Images only pushed to GHCR from master branch
- Test locally with `act -j build -W .github/workflows/<image-name>.yml --dryrun`

## Testing

Before committing:
- Build Docker image locally and verify functionality: `./scripts/build.sh -r <image-name>`
- Test the image interactively to ensure all tools work correctly
- Test workflow with `act` in dry-run mode: `./scripts/test-workflow.sh <image-name>`
- Test all README examples
- Check image size is reasonable

### Multi-Platform Build Testing

When building for `linux/amd64,linux/arm64`:

**Check for QEMU emulation issues:**
1. Monitor build logs for both platforms
2. Look for suspiciously fast completion times (~0.1s) on ARM64
3. Verify that long-running commands (pip install) actually execute
4. Test the published image on both platforms if possible

**Signs of QEMU failure:**
- ARM64 build step completes in 0.1s while AMD64 takes minutes
- No error messages but packages aren't installed
- Shell initialization scripts (source, export.sh) exit silently

**Solutions if ARM64 fails:**
1. Use direct venv paths instead of shell sourcing
2. Use `python -m` for command verification
3. Consider building AMD64 only (works via Rosetta 2 on Mac M1/M2)

### Testing Workflows with GitHub CLI

Use `gh` CLI for remote workflow testing:

**Trigger workflow manually:**
```bash
# ESP-IDF example
gh workflow run "üê≥ ESP-IDF Docker Image" --ref master \
  -f esp_idf_version=v5.4.1 \
  -f force_rebuild=true

# PlatformIO example
gh workflow run "üê≥ PlatformIO Docker Image" --ref master \
  -f pio_version=6.1.18 \
  -f force_rebuild=true
```

**Monitor workflow status:**
```bash
# List recent runs
gh run list --workflow="üê≥ ESP-IDF Docker Image" --limit 5

# Watch live progress
gh run watch

# View specific run
gh run view <run-id>

# Open in browser
gh run view <run-id> --web

# Check logs
gh run view <run-id> --log
gh run view <run-id> --log-failed
```

**Automated monitoring script:**
```bash
# Trigger and monitor until completion
RUN_ID=$(gh workflow run "üê≥ ESP-IDF Docker Image" --ref master \
  -f esp_idf_version=v5.4.1 -f force_rebuild=true --json 2>&1 | \
  gh run list --limit 1 --json databaseId -q '.[0].databaseId')
gh run watch $RUN_ID
```
