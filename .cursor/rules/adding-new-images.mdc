---
alwaysApply: true
---
# Adding New Docker Images

## Workflow

1. **Create Dockerfile** - Write and refine the Dockerfile
2. **Build Locally** - Build and test the image thoroughly
3. **Create Workflow** - Add GitHub Actions workflow for CI/CD
4. **Generate Documentation** - Only after successful build, create README

## Directory Structure

Create new directory: `images/<image-name>/` containing:
- `Dockerfile` - Image definition
- `README.md` - Comprehensive documentation
- Supporting files as needed

## Dockerfile Requirements

- Base image with version
- Build arguments for version pinning
- Environment variables for tool paths
- Working directory `/workspace`
- Verification step
- Layer optimization (combine RUN commands, cleanup)

## README Requirements

Image README must include:
- Overview and description
- What's Inside (specific versions)
- Quick Start (pull, build, run)
- Usage Examples
- CI/CD Integration examples
- Environment Variables
- Building the Image

- Version Information table

## Update Root README

Add new image to the table in root README. Keep it minimal - just image name, brief description, and link.

## Registry Naming

Images published as: `ghcr.io/jethome-iot/jethome-dev-<image-name>`

## GitHub Actions Workflow

Create `.github/workflows/<image-name>.yml`:
- Use inline matrix builds for multi-platform support (amd64/arm64)
- Set triggers for image directory and workflow file changes
- Define versions directly in matrix strategy
- Build job creates platform-specific images in parallel
- Create-manifest job combines platform images into multi-arch manifest
- Pass version to Dockerfile via `build_args` in matrix
- Images only pushed to GHCR from master branch
- Dev and PR branches: build-only validation (no push)
- Test locally with `act -j build -W .github/workflows/<image-name>.yml --dryrun`

**Workflow structure:**
- `build` job: Matrix with platforms [amd64, arm64] √ó versions
- `create-manifest` job: Combines platform images (only on master)
- Platform-specific tags: `<prefix>-<version>-linux-amd64`, `<prefix>-<version>-linux-arm64`
- Multi-arch tags: `latest`, `stable`, `<prefix>-<version>`, date, SHA

## Testing

Before committing:
- Build Docker image locally and verify functionality: `./scripts/build.sh -r <image-name>`
- Test the image interactively to ensure all tools work correctly
- Test workflow with `act` in dry-run mode: `./scripts/test-workflow.sh <image-name>`
- Test all README examples
- Check image size is reasonable

### Multi-Platform Build Testing

When building for `linux/amd64,linux/arm64`:

**Check for QEMU emulation issues:**
1. Monitor build logs for both platforms
2. Look for suspiciously fast completion times (~0.1s) on ARM64
3. Verify that long-running commands (pip install) actually execute
4. Test the published image on both platforms if possible

**Signs of QEMU failure:**
- ARM64 build step completes in 0.1s while AMD64 takes minutes
- No error messages but packages aren't installed
- Shell initialization scripts (source, export.sh) exit silently

**Solutions if ARM64 fails:**
1. Use direct venv paths instead of shell sourcing
2. Use `python -m` for command verification
3. Consider building AMD64 only (works via Rosetta 2 on Mac M1/M2)

### Testing Workflows with GitHub CLI

Use `gh` CLI for remote workflow testing:

**Trigger workflows:**

Workflows are triggered automatically by pushing to master or dev branches:

```bash
# Push to dev branch for testing (build-only, no push to GHCR)
git checkout dev
git push origin dev

# After validation, merge to master (builds and pushes to GHCR)
git checkout master
git merge dev
git push origin master
```

**Monitor workflow status:**
```bash
# List recent runs
gh run list --workflow="üê≥ ESP-IDF Docker Image" --limit 5

# Watch live progress
gh run watch

# View specific run
gh run view <run-id>

# Open in browser
gh run view <run-id> --web

# Check logs
gh run view <run-id> --log
gh run view <run-id> --log-failed
```

**Monitor latest run:**
```bash
# Get latest workflow run
WORKFLOW="üê≥ ESP-IDF Docker Image"
RUN_ID=$(gh run list --workflow="$WORKFLOW" --limit 1 \
  --json databaseId -q '.[0].databaseId')

# Monitor until completion
gh run watch $RUN_ID

# Check final status
CONCLUSION=$(gh run view $RUN_ID --json conclusion -q '.conclusion')
if [ "$CONCLUSION" = "success" ]; then
  echo "‚úÖ Workflow succeeded"
else
  echo "‚ùå Workflow failed"
  gh run view $RUN_ID --log-failed
fi
```
