---
alwaysApply: true
---
# GitHub Actions Standards

## Workflow Naming

Use emoji icons for better visibility:

```yaml
name: üê≥ Docker Build Workflow
```

Common icons:
- üê≥ Docker builds
- üîß Build/compile
- üß™ Testing
- üì¶ Package/release
- üöÄ Deployment

## Step Icons

Add emoji to step names for readability:

- üì• Checkout code
- üîß Setup/configure tools
- üîê Authentication
- üê≥ Docker operations
- üß™ Run tests
- üöÄ Deploy

## Per-Image Workflows

Each image should have its own workflow file:
- Naming: `.github/workflows/<image-name>.yml`
- Trigger on relevant file changes only
- Use reusable workflow: `.github/workflows/docker-build.yml`
- Images are **only pushed to GHCR from master branch**
- Dev and PR branches build only (no push)

### Workflow Structure

Standard pattern for image workflows:

```yaml
name: üê≥ <Image Name> Docker Image

env:
  DEFAULT_VERSION: v1.0.0

on:
  push:
    branches: [master, dev]
    paths:
      - '.github/workflows/<image-name>.yml'
      - '.github/workflows/docker-build.yml'
      - 'images/<image-name>/**'
  pull_request:
    branches: [master, dev]
    paths:
      - '.github/workflows/<image-name>.yml'
      - '.github/workflows/docker-build.yml'
      - 'images/<image-name>/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (e.g., v1.0.0)'
        required: true
        type: string
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean
      custom_tags:
        description: 'Additional custom tags (comma-separated, optional)'
        required: false
        default: ''
        type: string

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: üè∑Ô∏è Resolve version
        id: version
        run: |
          VERSION="${{ github.event.inputs.version || env.DEFAULT_VERSION }}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Using version: ${VERSION}"

  build:
    needs: prepare
    uses: ./.github/workflows/docker-build.yml
    permissions:
      contents: read
      packages: write
    with:
      image_name: jethome-dev-<image-name>
      context_path: images/<image-name>
      version_tag: <prefix>-${{ needs.prepare.outputs.version }}
      force_rebuild: ${{ github.event.inputs.force_rebuild || false }}
      custom_tags: ${{ github.event.inputs.custom_tags || '' }}
      build_args: |
        VERSION=${{ needs.prepare.outputs.version }}
```

### Version Handling

- Define default versions in `env` at workflow level (single source of truth)
- Use `prepare` job to resolve version (inputs or env default)
- Pass resolved version via job outputs to build job
- `env` context available in job steps, outputs available in `with:`
- Easy to override manually via GitHub UI (workflow_dispatch inputs)

### Push Behavior by Branch

| Branch/Event | Build | Push to GHCR | Tags Generated |
|--------------|-------|--------------|----------------|
| Master | Yes | Yes | `latest`, `stable`, `VERSION`, `sha-SHA` |
| Dev | Yes | No | None |
| Pull Request | Yes | No | None |

**Rationale:**
- Keeps GHCR clean with only released images
- Faster CI on dev branches (build-only validation)
- Clear release strategy: master = production/stable
- Dev branch for testing before release

## Workflow Testing

### Local Testing with act

Test workflows locally using `act`:
- Configuration in `.actrc`
- Test specific job: `act -j build`
- Use `.secrets` file for local secrets (gitignored)
- Helper script: `./scripts/test-workflow.sh <image-name>`

### Remote Testing with GitHub CLI

Use `gh` CLI to test workflows on GitHub Actions:

**Manual Workflow Dispatch:**
```bash
# Trigger workflow with parameters
gh workflow run "üê≥ <Workflow Name>" --ref master \
  -f version=v1.0.0 \
  -f force_rebuild=true \
  -f custom_tags=test

# Example: ESP-IDF
gh workflow run "üê≥ ESP-IDF Docker Image" --ref master \
  -f esp_idf_version=v5.4.1 \
  -f force_rebuild=true

# Example: PlatformIO
gh workflow run "üê≥ PlatformIO Docker Image" --ref master \
  -f pio_version=6.1.18 \
  -f force_rebuild=false
```

**Monitoring Workflows:**
```bash
# List recent workflow runs
gh run list --workflow="üê≥ ESP-IDF Docker Image" --limit 10

# Watch workflow in real-time
gh run watch

# View specific run details
gh run view <run-id>
gh run view <run-id> --json

# Open run in browser
gh run view <run-id> --web

# View logs
gh run view <run-id> --log
gh run view <run-id> --log-failed  # Only failed jobs
```

**Query Run Status:**
```bash
# Get run status programmatically
gh run view <run-id> --json status,conclusion | \
  jq -r '"\(.status):\(.conclusion // "N/A")"'

# Get all jobs status
gh api /repos/:owner/:repo/actions/runs/<run-id>/jobs | \
  jq -r '.jobs[] | "\(.name): \(.status) - \(.conclusion // "N/A")"'
```

**Automated Testing Script Example:**
```bash
#!/bin/bash
# Trigger workflow and wait for completion

WORKFLOW="üê≥ ESP-IDF Docker Image"
VERSION="v5.4.1"

# Trigger workflow
gh workflow run "$WORKFLOW" --ref master \
  -f esp_idf_version=$VERSION \
  -f force_rebuild=true

# Wait for workflow to appear
sleep 10

# Get latest run ID
RUN_ID=$(gh run list --workflow="$WORKFLOW" --limit 1 \
  --json databaseId -q '.[0].databaseId')

echo "Monitoring workflow run: $RUN_ID"

# Monitor until completion
while true; do
  STATUS=$(gh run view $RUN_ID --json status,conclusion | \
    jq -r '.status')
  
  if [ "$STATUS" = "completed" ]; then
    CONCLUSION=$(gh run view $RUN_ID --json conclusion | \
      jq -r '.conclusion')
    echo "Workflow completed: $CONCLUSION"
    
    if [ "$CONCLUSION" = "success" ]; then
      exit 0
    else
      gh run view $RUN_ID --log-failed
      exit 1
    fi
  fi
  
  echo "Status: $STATUS"
  sleep 20
done
```

### Testing Best Practices

1. **Local first**: Test with `act` before pushing
2. **Force rebuild**: Use `force_rebuild=true` to bypass Docker cache when testing fixes
3. **Monitor logs**: Always check logs for build errors, even on "success"
4. **Verify image**: Pull and test the published image after successful build
5. **Branch strategy**: Test on `dev` branch first, then merge to `master` for release
