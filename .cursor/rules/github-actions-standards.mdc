---
alwaysApply: true
---
# GitHub Actions Standards

## Workflow Naming

Use emoji icons for better visibility:

```yaml
name: üê≥ Docker Build Workflow
```

Common icons:
- üê≥ Docker builds
- üîß Build/compile
- üß™ Testing
- üì¶ Package/release
- üöÄ Deployment

## Step Icons

Add emoji to step names for readability:

- üì• Checkout code
- üîß Setup/configure tools
- üîê Authentication
- üê≥ Docker operations
- üß™ Run tests
- üöÄ Deploy

## Per-Image Workflows

Each image should have its own workflow file:
- Naming: `.github/workflows/<image-name>.yml`
- Trigger on relevant file changes only
- Use inline matrix builds for multi-platform support (amd64/arm64)
- Images are **only pushed to GHCR from master branch**
- Dev and PR branches build only (no push)

### Workflow Structure

Standard pattern for image workflows with matrix builds:

```yaml
name: üê≥ <Image Name> Docker Image

on:
  push:
    branches: [master, dev]
    paths:
      - '.github/workflows/<image-name>.yml'
      - 'images/<image-name>/**'
  pull_request:
    branches: [master, dev]
    paths:
      - '.github/workflows/<image-name>.yml'
      - 'images/<image-name>/**'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: jethome-dev-<image-name>

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
        version: ['1.0.0']  # Can expand to multiple versions
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        
      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: üîê Log in to GitHub Container Registry
        if: github.ref_name == 'master'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üè∑Ô∏è Prepare platform tag
        id: platform
        run: |
          PLATFORM_PAIR=${{ matrix.platform }}
          PLATFORM_TAG=$(echo $PLATFORM_PAIR | sed 's/\//-/g')
          echo "tag=${PLATFORM_TAG}" >> $GITHUB_OUTPUT
          
      - name: üê≥ Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: images/<image-name>
          platforms: ${{ matrix.platform }}
          push: ${{ github.ref_name == 'master' }}
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:<prefix>-${{ matrix.version }}-${{ steps.platform.outputs.tag }}
          cache-from: type=gha,scope=${{ env.IMAGE_NAME }}-${{ steps.platform.outputs.tag }}
          cache-to: type=gha,mode=max,scope=${{ env.IMAGE_NAME }}-${{ steps.platform.outputs.tag }}
          build-args: |
            VERSION=${{ matrix.version }}

  create-manifest:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref_name == 'master'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        version: ['1.0.0']  # Must match build job matrix
    steps:
      - name: üîê Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: üè∑Ô∏è Generate version and date tags
        id: tags
        run: |
          SHA_SHORT=$(echo "${{ github.sha }}" | cut -c1-7)
          DATE_TAG=$(date +%Y.%m.%d)
          echo "sha_short=${SHA_SHORT}" >> $GITHUB_OUTPUT
          echo "date_tag=${DATE_TAG}" >> $GITHUB_OUTPUT
          
      - name: üéØ Create multi-arch manifest
        run: |
          docker buildx imagetools create -t ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:stable \
            -t ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:<prefix>-${{ matrix.version }} \
            -t ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.tags.outputs.date_tag }} \
            -t ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:sha-${{ steps.tags.outputs.sha_short }} \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:<prefix>-${{ matrix.version }}-linux-amd64 \
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:<prefix>-${{ matrix.version }}-linux-arm64
```

**Critical Details:**
- Matrix builds both platforms in parallel for faster CI
- Platform-specific images tagged with arch suffix (e.g., `pio-6.1.18-linux-amd64`)
- Manifest job combines platform images into multi-arch manifest
- Only master branch pushes images; dev/PR do build-only validation
- Version matrix can be expanded to build multiple versions
- Simple `workflow_dispatch` trigger allows manual runs from GitHub UI (no parameters)

### Version Handling

- Define versions directly in matrix strategy
- Can expand to multiple versions: `version: ['1.0.0', '1.1.0']`
- Each version builds for all platforms in the matrix
- Matrix generates all combinations: platforms √ó versions

### Push Behavior by Branch

| Branch/Event | Build | Push to GHCR | Tags Generated |
|--------------|-------|--------------|----------------|
| Master | Yes | Yes | `latest`, `stable`, `VERSION`, `sha-SHA` |
| Dev | Yes | No | None |
| Pull Request | Yes | No | None |

**Rationale:**
- Keeps GHCR clean with only released images
- Faster CI on dev branches (build-only validation)
- Clear release strategy: master = production/stable
- Dev branch for testing before release

## Workflow Testing

### Local Testing with act

Test workflows locally using `act`:
- Configuration in `.actrc`
- Test specific job: `act -j build`
- Use `.secrets` file for local secrets (gitignored)
- Helper script: `./scripts/test-workflow.sh <image-name>`

### Remote Testing with GitHub CLI

Use `gh` CLI to test workflows on GitHub Actions:

**Triggering Workflows:**

Workflows can be triggered in two ways:

1. **Automatically** - by pushing to master or dev branches:
```bash
# Push to dev branch for testing (build-only, no push to GHCR)
git checkout dev
git push origin dev

# After validation, merge to master (builds and pushes to GHCR)
git checkout master
git merge dev
git push origin master
```

2. **Manually** - via GitHub Actions UI:
   - Go to Actions tab ‚Üí Select workflow ‚Üí Run workflow
   - Select branch (master or dev) and click "Run workflow"
   - Uses default versions from matrix

**Monitoring Workflows:**
```bash
# List recent workflow runs
gh run list --workflow="üê≥ ESP-IDF Docker Image" --limit 10

# Watch workflow in real-time
gh run watch

# View specific run details
gh run view <run-id>
gh run view <run-id> --json

# Open run in browser
gh run view <run-id> --web

# View logs
gh run view <run-id> --log
gh run view <run-id> --log-failed  # Only failed jobs
```

**Query Run Status:**
```bash
# Get run status programmatically
gh run view <run-id> --json status,conclusion | \
  jq -r '"\(.status):\(.conclusion // "N/A")"'

# Get all jobs status
gh api /repos/:owner/:repo/actions/runs/<run-id>/jobs | \
  jq -r '.jobs[] | "\(.name): \(.status) - \(.conclusion // "N/A")"'
```

**Monitoring Latest Run:**
```bash
# Get latest workflow run for a specific workflow
WORKFLOW="üê≥ ESP-IDF Docker Image"
RUN_ID=$(gh run list --workflow="$WORKFLOW" --limit 1 \
  --json databaseId -q '.[0].databaseId')

# Monitor until completion
gh run watch $RUN_ID

# Check final status
CONCLUSION=$(gh run view $RUN_ID --json conclusion -q '.conclusion')
if [ "$CONCLUSION" = "success" ]; then
  echo "‚úÖ Workflow succeeded"
else
  echo "‚ùå Workflow failed"
  gh run view $RUN_ID --log-failed
fi
```

### Testing Best Practices

1. **Local first**: Test with `act` before pushing
2. **Branch strategy**: Always test on `dev` branch first
   - Push to dev for build validation (no GHCR push)
   - Review workflow logs for both platforms
   - Merge to master only after successful dev validation
3. **Monitor logs**: Always check logs for build errors, even on "success"
   - Check both amd64 and arm64 build logs (matrix creates separate jobs)
   - Verify both platform builds complete successfully
   - Ensure build times are reasonable for both architectures
4. **Verify images**: Pull and test the published image after successful master build
   - Test multi-arch manifest: `docker pull <image>:latest`
   - Verify on your architecture: `docker run --rm <image>:latest <command>`
   - Check that correct platform is pulled automatically
5. **Cache management**: GitHub Actions cache persists between runs
   - Cache is per-platform (separate for amd64/arm64)
   - To force fresh build, clear GitHub Actions cache via Settings ‚Üí Actions ‚Üí Caches
